<!DOCTYPE html>
<html lang="ru" dir="ltr">
  <head>
    <meta charset="utf-8">
    <meta name="description" content="СКОРОСТЬ ЗАГРУЗКИ">
    <meta name="author" content="@doochik">
    <title>Блог компании Яндекс.</title>
  </head>
  <body>
    <header>
        <hgroup>
          <h3>Блог компании Яндекс.</h3>
          <h2>ЯНДЕКС.ПОЧТА: КАК МЫ ИЗМЕРЯЕМ СКОРОСТЬ ЗАГРУЗКИ И УЛУЧШАЕМ ЕЁ</h2>
        </hgroup>
    </header>
      <article>
          <div style="color:maroon;"">
          <p>Если ваш сайт медленно грузится, вы рискуете тем, что люди не оценят ни то,<br>
        какой он красивый, ни то, какой он удобный. Никому не понравится, когда все <br>
        тормозит. Мы регулярно добавляем в Яндекс.Почту новую функциональность,<br>
        иногда — исправляем ошибки, а это значит, у нас постоянно появляются новый код<br>
        и новая логика. Всё это напрямую влияет на скорость работы интерфейса.</p>
        </div>
      </article>


      <section>

        <header>
          <h4>Что мы измеряем</h4>
        </header>

       <article>

       <p>Этапы первой загрузки:</p>
       <ul>
           <li>подготовка;</li>
           <li>загрузка статики (HTTP-запрос и парсинг);</li>
           <li>исполнение модулей;</li>
           <li>инициализация базовых объектов;</li>
           <li>отрисовка.</li>
       </ul>


       <p>Этапы отрисовки любой страницы:</p>
       <ul>
           <li>подготовка к запросу на сервер;</li>
           <li>запрос данных с сервера;</li>
           <li>шаблонизация;</li>
           <li>обновление DOM.</li>
       </ul>

       <p>— <q>Ок, теперь у нас есть метрики, мы можем отправить их на сервер</q> - говорим мы</p>
       <p>— <q>Что же дальше?</q> - вопрошаете вы</p>
       <p>— <q>А давай построим график!</q> - отвечаем мы</p>
       <p>— <q>А что будем считать?</q> - уточняете вы</p>

       <p>Как вы знаете, <dfn>медиана</dfn> – это серединное, а не среднее значение в выборке.<br>
       Если у нас имеются числа 1, 2, 2, 3, 8, 10, 20, то медиана – 3, а среднее – 6,5.<br>
       В общем случае медиана отлично показывает, сколько грузится средний пользователь.</p>

       <p>В случае ускорения или замедления медиана, конечно, изменится. Но она не может <br>
       рассказать, сколько пользователей ускорилось, а сколько замедлилось.</p>

       <p><dfn>APDEX</dfn> – метрика, которая сразу говорит: хорошо или плохо. Метрика <br>
       работает очень просто. Мы выбираем временной интервал [0; t], такой, что если <br>
       время показа страницы попало в него, то пользователь счастлив. Берем еще один <br>
       интервал, (t; 4t] (в четыре раза больше первого), и считаем, что если страница <br>
       показана за это время, то пользователь в целом удовлетворен скоростью работы, <br>
       но уже не настолько счастлив. И применяем формулу:</p>

       <p>(кол-во счастливых пользователей + кол-во удовлетворенных / 2) / (кол-во всех).<br>
       Получается значение от нуля до единицы, которое, видимо, лучше всего показывает, <br>
       хорошо или плохо работает почта.<p>
    </article>
    </section>

    <section>

      <header>

         <h4>Как мы измеряем</h4>
      </header>
     <article>

       <p>Сейчас модуль обновления сам логирует все свои стадии, и можно легко понять <br>
       причину замедления: медленнее стал отвечать сервер либо слишком долго <br>
       выполняется JavaScript. Выглядит это примерно так:</p>
       <code>
          this.timings['look-ma-im-start'] = Date.now();<br>
          this.timings['look-ma-finish'] = Date.now();
       </code>


      <p>C помощью <code>Date.now()</code> мы получаем текущее время. Все тайминги собираются и при <br>
      отправке рассчитываются. На этапах разница между <q>end</q> и <q>start</q>не считается, <br>
      а все вычисления производятся в конце:</p>
      <code>
         var totalTime = this.timings['look-ma-finish'] - this.timings['look-ma-im-start'];
      </code>

      <p>И на сервер прилетают подобные записи:</p>
      <code>
         serverResponse=50&domUpdate=60
      </code>
   </article>
   </section>

   <section>
     <header>

        <h4>Как мы ускоряем</h4>
     </header>

    <article>

        <p>Чтобы снизить время загрузки почты при выходе новых версий, <br>
        мы уже делаем следующее:</p>
        <ul>
           <li>включаем gzip;</li>
           <li>выставляем заголовки кэширования;</li>
           <li>фризим CSS, JS, шаблоны и картинки;</li>
           <li>используем CDN;</li>
        </ul>

        <p>Мы подумали: <q>А что если хранить где-то старую версию файлов, а при выходе новой <br>
        передавать только diff между ней и той, которая сохранена у пользователя?</q> <br>
        В браузере же останется просто наложить патч на клиенте.</p>
        <p>На самое деле эта идея не нова. Уже существуют стандарты для HTTP — например, <br>
        RFC 3229 <q >Delta encoding in HTTP</q> и <q>Google SDHC</q>, — но по разным причинам они <br>
        не получили должного распространения в браузерах и на серверах.</p>

        <p>Мы же решили сделать свой аналог на JS. Чтобы реализовать этот метод обновления, <br>
        начали искать реализации diff на JS. На популярных хостингах кода нашли <br>
        библиотеки:</p>
        <p>- VCDiff</p>
        <p>- google-diff-patch-match</p>
        <p>Для окончательного выбора библиотеки нам нужно сравнить:</p>
        <table>
          <thead><!--Шапка таблицы-->
           <tr>
             <th>Библиотека</th> <th>|IE 9</th> <th>|Opera 12</th>
           </tr>
        </thead>
        <tbody>
          <tr>
           <td>-----------------</td><td>|------</td> <td>|------------</td>
          </tr>
          <tr>
           <td>vcdiff</td> <td>|8</td> <td>|5</td>
          </tr>
          <tr>
           <td>google diff</td> <td>|1363</td><td>|76</td>
          </tr>
        </tbody>
       </table>



       <p>После того как мы определились с библиотекой для диффа, нужно определиться с тем, <br>
       где и как хранить статику на клиенте.</p>

       <figure>
        <figcaption>Формат файла с патчами для проекта выглядит так:</figcaption>
        <pre>
    [
        {
            "k": "jane.css",
            "p": [patch],
            "s": 4554
        },
        {
            "k": "jane.css",
            "p": [patch],
            "s": 4554
        }
    ]
         </pre>
       </figure>


       <p>То есть это обычный массив из объектов. Каждый объект — отдельный ресурс. У <br>
       каждого объекта есть три свойства. k — названия ключа в localStorage для этого <br>
       ресурса. p — патч для ресурса, который сгенерировал vcdiff. s — чексумма для <br>
       ресурса актуальной версии, чтобы потом можно было проверить правильность <br>
       наложения патча на клиенте. Чексумма вычисляется по алгоритму Флетчера.</P>
       <article >
         <math>
         <p>дано &xi;, x <sub>0</sub> <br>
         инициализировать H <sub>0</sub><br>
         k=0 <br>
         <strong>while</strong>||&nabla; f <sub>k</sub>||>&xi;<br>
         </p>
         <blockquote>найти направление p <sub>k</sub>=-C<sub>k</sub>&nabla;&fnof;<sub>k</sub> <br>
          вычислить x <sub>k+1</sub>=x <sub>k</sub><mo> + </ mo>a <sub>k</sub>p <sub>k</sub>, a<sub>k</sub> удовлетворяет условиям Вольфе<br>
          обозначить s <sub>k</sub>=x <sub>k+1</sub>-x <sub>k</sub> и y <sub>k</sub>=&nabla;&fnof;<sub>k+1</sub>-&nabla;&fnof;<sub>k</sub> <br>
          вычислить C <sub>k+1</sub><br>
          k=k<mo> + </ mo>1 <br>
         </blockquote>
         <strong>end</strong>
         </math>
       </article>
       <p><dfn>Алгоритм Бройдена — Флетчера — Гольдфарба — Шанно (<abbr title="Алгоритм Бройдена — Флетчера — Гольдфарба — Шанно">BFGS</abbr>)</dfn><br>
       — итерационный метод численной оптимизации, предназначенный для <br>
       нахождения локального максимума/минимума нелинейного функционала <br>
       без ограничений.</p>

      <p>Почему именно алгоритм Флетчера, а не другие популярные алгоритмы вроде: <br>
      <dfn>CRC16/32</dfn> - алгоритм нахождения контрольной суммы, предназначенный для проверки <br>
      целостности данных</p>
      <p><dfn>md5</dfn> - 128-битный алгоритм хеширования. Предназначен для создания «отпечатков» <br>
      или дайджестов сообщения произвольной длины и последующей проверки <br>
      их подлинности.</p>

      <p>Потому что он быстрый, компактный и легок в реализации.</p>
   </article>
   </section>

   <section>
     <header>

       <h3>Итог</h3>
     </header>
   <article>

     <p>Фактически мы экономим 80-90% трафика. Размер загружаемой статитки в байтах:</p>
     <table>
        <thead><!--Шапка таблицы-->
          <tr>
           <th>Релиз</th> <th>| С патчем</th> <th>| Без патча</th>
          </tr>
       </thead>
       <tbody>
         <tr>
           <td>7.7.20</td><td>|397</td> <td>|174 549</td>
         </tr>
         <tr>
           <td>7.7.21</td> <td>|383</td> <td>|53 995</td>
         </tr>
         <tr>
           <td>7.7.22</td> <td>|483</td><td>|3 995</td>
         </tr>
       </tbody>
    </table>
   </article>
   <footer>
   <address >
     <p>Автор: @doochik <br>
     С++ разработик <br>
     Электронная почта: (<a href="mailto:doochik@yandex-team.ru">doochik@yandex-team.ru</a>) <br>
     Компания: Яндекс</p>
   </address>
   </footer>
   </section>

   <section>
     <header>

       <h3>Комментарии (3):</h3>
     </header>
     <p>- Mogaika (<a href="mailto:mogaika@yandex-team.ru">mogaika@yandex-team.ru</a>) 30 ноября 2014 в 17:05</p>
     <blockquote>
       А можете привести сравнение, на сколько быстрее грузится lite версия?
     </blockquote>

     <p>- JIguse (<a href="mailto:mrawesome@yandex.ru">mrawesome@yandex.ru</a>) 29 ноября 2014 в 21:30</p>
     <blockquote>
       Спасибо за статью, познавательно. Здорово, что Яндекс делится некоторыми
       подробностями о внутренней работе сервисов.
     </blockquote>
     <p>- Brister (<a href="mailto:rist89@yandex-team.ru">rist89@yandex-team.ru</a>) 24 ноября 2014 в 13:13</p>

    <blockquote>

      <p>(кол-во счастливых пользователей + кол-во удовлетворенных / 2) / (кол-во всех). <br>
      Получается значение от нуля до единицы, которое, видимо, лучше всего показывает,<br>
      хорошо или плохо работает почта.</p>

      <p>наверное все-таки от 0.5 до 1</p>
    </blockquote>
    <p>- alexeimois ( <a href="mailto:test@yandex.ru">test@yandex.ru</a>) 22 ноября 2014 в 17:35</p>

    <p>Мы измеряем скорость загрузки с помощью Яндекс.Метрики:<br>
    <a href="cite:help.yandex.ru/metrika/reports/monitoring_timing.xml">help.yandex.ru/metrika/reports/monitoring_timing.xml</a></p>
  </section>
  <footer>
    <P>&copy Яндекс,  <a href="mailto:help@yandex.ru">help@yandex.ru</a>, Хохрякова, 10<p>
  </footer>
  </body>
</html>
